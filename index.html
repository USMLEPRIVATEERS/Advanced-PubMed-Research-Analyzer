<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PubMed Research Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      #filters {
    overflow-y: auto;
    max-height: calc(100vh - 4rem);
    scrollbar-width: thin; /* For Firefox */
    scrollbar-color: var(--border-color) var(--surface-color);
}

#filters::-webkit-scrollbar {
    width: 6px; /* Thin width */
}

#filters::-webkit-scrollbar-track {
    background: var(--surface-color); /* Darker track */
    border-radius: 10px;
}

#filters::-webkit-scrollbar-thumb {
    background: var(--border-color); /* Dark thumb */
    border-radius: 10px;
}

#filters::-webkit-scrollbar-thumb:hover {
    background: #555; /* Slightly lighter on hover for better UX */
}
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #3498db;
            --primary-hover: #2980b9;
            --text-color: #f5f5f5;
            --text-muted-color: #9e9e9e;
            --border-color: #333;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --font-family: 'Inter', sans-serif;
            --success-color: #27ae60;
            --warning-color: #f39c12;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2rem;
            font-size: 16px;
        }

        /* --- Main Layout & Header --- */
        .container {
            max-width: 1600px;
            margin: auto;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        header {
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 1.5rem;
        }

        header h1 {
            font-size: 2.5rem;
            margin: 0;
            color: var(--primary-color);
            font-weight: 700;
        }

        header p {
            font-size: 1.1rem;
            color: var(--text-muted-color);
            max-width: 700px;
            margin: 0.5rem auto 0;
        }
        
        /* --- File Input with Drag & Drop --- */
        .file-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
            background-color: var(--surface-color);
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .file-upload-area:hover, .file-upload-area.drag-over {
            background-color: #2a2a2a;
            border-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .file-upload-area.drag-over {
            background-color: rgba(52, 152, 219, 0.1);
            border-color: var(--success-color);
        }

        .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .file-label {
            background-color: var(--primary-color);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
            border: none;
        }
        
        .file-label:hover {
            background-color: var(--primary-hover);
        }

        #fileInput {
            display: none;
        }

        #file-list {
            color: var(--text-muted-color);
            font-style: italic;
        }

        /* --- Action Buttons --- */
        .action-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .action-btn {
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .action-btn:hover {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- Dashboard --- */
        #dashboard {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 2rem;
            align-items: start;
        }

        /* --- Filters --- */
        #filters {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: sticky;
            top: 2rem;
        }

        .filter-group {
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
        }

        .filter-group h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.75rem;
        }
        
        .filter-group select {
            width: 100%;
            padding: 10px;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        
        .filter-group select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        /* --- Main Content --- */
        #main-content {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            min-width: 0;
        }

        /* --- View Toggle --- */
        .view-toggle {
            display: flex;
            background-color: var(--surface-color);
            border-radius: 12px;
            padding: 0.5rem;
            gap: 0.5rem;
        }

        .view-btn {
            flex: 1;
            padding: 10px;
            background: none;
            border: none;
            color: var(--text-muted-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .view-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* --- Charts --- */
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
        }

        .chart-wrapper {
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            position: relative;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .chart-wrapper:hover {
            transform: translateY(-2px);
        }

        .chart-expand-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(52, 152, 219, 0.8);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* --- Map --- */
        #mapView {
            height: 600px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px var(--shadow-color);
        }

        /* --- Results List --- */
        #results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: var(--surface-color);
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
        }
        
        #results-count {
            font-weight: 500;
        }

        #results-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .study-item {
            background-color: var(--surface-color);
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            overflow: hidden;
            border: 1px solid transparent;
            transition: border-color 0.3s;
        }

        .study-item:hover {
            border-color: var(--primary-color);
        }

        .study-header {
            padding: 1.5rem;
        }

        .study-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 0.75rem 0;
        }
        
        .study-link {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }
        
        .study-link:hover {
            text-decoration: underline;
        }

        .abstract-toggle {
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            color: var(--text-muted-color);
            background-color: rgba(255, 255, 255, 0.03);
            border-top: 1px solid var(--border-color);
            transition: background-color 0.3s;
        }

        .abstract-toggle:hover {
            background-color: rgba(255, 255, 255, 0.07);
        }
        
        .abstract-toggle::after {
            content: '‚ñº';
            float: right;
            transition: transform 0.3s;
        }
        
        .abstract-toggle.open::after {
            transform: rotate(180deg);
        }

        .abstract-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            padding: 0 1.5rem;
            line-height: 1.6;
        }

        .abstract-content.open {
            max-height: 1000px;
            padding: 1.5rem;
        }

        /* --- Modal --- */
        .modal {
            display: flex;
            align-items: center;
            justify-content: center;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .modal.open {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--surface-color);
            padding: 2.5rem;
            border-radius: 12px;
            box-shadow: 0 5px 25px var(--shadow-color);
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            transform: scale(0.95);
            transition: transform 0.3s;
        }
        
        .modal.open .modal-content {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.8rem;
            color: var(--primary-color);
        }

        .close-button {
            background: none;
            border: none;
            font-size: 2.5rem;
            color: var(--text-muted-color);
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-button:hover {
            color: var(--text-color);
        }
        
        .modal-body p {
            line-height: 1.7;
            color: var(--text-muted-color);
        }
        .modal-body strong {
            color: var(--text-color);
        }

        .chart-modal-content {
            height: 70vh;
            width: 100%;
        }
        
        /* --- Loader --- */
        #loader {
            display: none;
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--primary-color);
            animation: spin 1s ease infinite;
            margin: 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* --- Hidden class --- */
        .hidden {
            display: none !important;
        }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            # The user wants me to rewrite the code so that when a filter is applied, it updates the other filters to only show options that still have studies available.

The code is an HTML page with JavaScript for a PubMed Research Analyzer. It has filters for USA Authors, Location (State and City), Department, and Researcher.

Currently, the filters are populated once with all possible values from the studies. When filters are applied, it just filters the studies but doesn't update the filter options.

I need to make it dynamic: when a filter changes, update the other select boxes to only include options that appear in the currently filtered studies.

For example, if I select a department, then the states should only show states that have studies in that department.

It should be interdependent.

The USA Author filter is different; it's not based on specific values but on criteria.

The filters are:

- usaAuthorFilter: select with fixed options (any, at-least-one, first, last, all)

- stateFilter

- cityFilter

- deptFilter

- researcherFilter

The dynamic ones are state, city, dept, researcher.

The usaAuthorFilter can stay fixed, as it's not value-based.

To implement this, in applyFilters(), after computing filteredStudies, I need to repopulate the other filters based on the current filteredStudies.

But since the filters are interdependent, when one changes, I need to update the others based on the current selections except for itself.

A common way is: when a filter changes, compute the filtered studies using all filters except the ones that need updating, but actually, it's better to compute the possible options for each filter based on the studies that match the other filters.

For each filter, the options should be those that appear in studies that match all the other filters.

When a filter is set to a specific value, the other filters show options compatible with that.

When reset to 'all', show all possible given the other selections.

To do this, I can modify populateFilters to take a set of studies and populate based on that.

But since there are multiple filters, I need a way to get the available options for each.

One way is: after applying filters, call a function to updateFilterOptions() which populates each select with options from the current filteredStudies, but that would include only the selected ones, no.

That's not right.

If I select state = "California", then filteredStudies are those with California.

Then, for cityFilter, I want to show only cities that appear in those California studies.

For deptFilter, only depts in California studies, etc.

But for stateFilter, since it's selected, it should stay with all states? No, when state is selected, the other filters update to match.

If I then select a city, say "Los Angeles", then filteredStudies become California + Los Angeles.

Then, I should update the other filters: deptFilter to depts in CA LA studies, researcher to those in CA LA, but stateFilter should now only show "California" ? Or keep all?

The user said: "update the other filters leaving just the ones with studies yet"

So, for the non-selected filters, show only options that have studies in the current filtered set.

But actually, since when a filter is 'all', it's not restricting.

The standard way in faceted search is: each filter shows counts/options based on the current search results, i.e., after applying other filters.

So, the options for a filter are those that appear in the current filteredStudies (which are filtered by the other selected filters).

But for the filter itself, if it's set to a value, its options should still show other possible values that could be selected instead.

But in this case, since it's single select, and 'all' is an option.

To make it dynamic:

In applyFilters():

1. Compute filteredStudies using all current filter values.

2. Then, update the options for all filters based on the full set, but no.

To show available options:

I need to compute for each filter, the possible values that, if selected, would not result in zero results, given the other filters.

For each filter, compute the studies that match all filters except this one, and then get the unique values for this filter from those studies.

That way, even if this filter is set to something, the options show all possible that are compatible with the other selections.

And for the count, often show counts.

But the user didn't ask for counts, just "leaving just the ones with studies yet"

So, only show options that have at least one study matching the other filters.

Yes.

To implement:

I can write a function getAvailableOptions(filterKey) {

  // compute studies filtered by all filters except this one

  const tempFiltered = allStudies.filter(study => {

    // check all conditions except the one for filterKey

  });

  then extract the unique values for that filter from tempFiltered.

}

Then, after applyFilters(), for each filter, populate it with getAvailableOptions(that filter), and restore the current selection if possible.

But to avoid infinite loops, since changing select triggers applyFilters, but populating shouldn't trigger change.

When populating, I can set a flag to ignore change events.

Or, better, populate only after filtering, and use removeEventListener/addEventListener around population.

But in JS, changing options doesn't trigger change, only user selection does.

No, setting value programmatically doesn't trigger change event.

Yes, so I can do:

In applyFilters():

  // compute filteredStudies using current values

  // render results, update charts etc.

  // then updateFilterOptions()

Where updateFilterOptions() {

  updateSelect(stateFilter, getAvailableStates());

  updateSelect(cityFilter, getAvailableCities());

  etc.

}

And getAvailableStates() {

  // filter studies using all filters except state

  const criteria = usaAuthorFilter.value;

  const selCity = cityFilter.value;

  const selDept = deptFilter.value;

  const selRes = researcherFilter.value;

  const tempFiltered = allStudies.filter(study => 

    checkUSAAuthorCriteria(study, criteria) &&

    (selCity === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.city === selCity))) &&

    (selDept === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.department === selDept))) &&

    (selRes === 'all' || study.authors.some(a => a.name === selRes))

  );

  // then extract unique states from tempFiltered

  const states = new Set();

  tempFiltered.forEach(study => {

    study.authors.forEach(author => {

      author.affiliations.forEach(aff => {

        if (aff.isUSA && aff.state) states.add(aff.state);

      });

    });

  });

  return [...states].sort();

}

Similarly for other filters.

For usaAuthorFilter, since it's fixed, no need to update its options.

Yes.

And for updateSelect(selectEl, availableItems) {

  const currentValue = selectEl.value;

  selectEl.innerHTML = '<option value="all">All ...</option>';

  availableItems.forEach(item => {

    const opt = document.createElement('option');

    opt.value = item;

    opt.text = item;

    selectEl.appendChild(opt);

  });

  // restore selection if still available, else set to 'all'

  if (currentValue !== 'all' && availableItems.includes(currentValue)) {

    selectEl.value = currentValue;

  } else {

    selectEl.value = 'all';

  }

}

If the current selection is no longer available, reset it to 'all' and maybe re-apply filters.

If I reset it, I need to call applyFilters again if changed.

To avoid recursion, I can check if value changed, and if so, call applyFilters.

Since change event is not triggered by code, I can manually check.

In updateFilterOptions, collect if any filter was reset, and if so, call applyFilters again at the end.

Since it's interdependent, it might need a loop until stable, but in practice, since resetting to 'all' broadens, it should be fine.

A safer way: compute all available options first, then update all selects, then if any was reset, call applyFilters recursively once.

To keep it simple, since the number is small, I can do it.

The user example: "I selected some department, so it will update the other filters leaving just the ones with studies yet"

When select dept, then update states to only those that have that dept, cities that have that dept, researchers that have that dept.

The current dept remains selected, and since getAvailableDepts would be computed ignoring the dept filter, so available depts are those compatible with other filters (which might be all if others are 'all').

When I select dept = X, then in applyFilters, filteredStudies are those with dept X (and others if set).

Then in updateFilterOptions, for states, getAvailableStates() ignores the state filter (which is 'all' probably), but uses the dept=X, so states from studies with dept=X.

For cities, same.

For researchers, same.

For depts, getAvailableDepts() would ignore dept filter, so use other filters (if any), and get all depts that appear in studies matching other filters.

Since dept was just selected to X, but if no other filters, available depts would be all depts, so it keeps showing all, including X.

But the user wants "leaving just the ones with studies yet", I think it means show only options that have studies in the current context.

But for the filter itself, should it show other depts that are available given other filters?

Yes, typically yes, so user can switch to another dept.

If I want to hide unavailable, but since when dept=X, the available depts ignoring dept would show all possible depts, but wait.

No, if other filters are set, say state=CA, then when ignoring dept, available depts are those in CA.

When I select dept=X, if X is in CA, it stays.

Yes.

For the selected filter, it still shows other options if they are compatible.

To "leave just the ones with studies yet", I think they mean update to show only relevant options.

In some systems, the facets show all possible, with counts, and gray out zero.

But since no counts, and selects, better to only include options with at least one.

Yes, and that's what the above does.

For a filter, by ignoring its own selection when computing available, it shows all options that would yield at least one if selected (given others).

And if the current value is not in available (which shouldn't happen unless external change), reset.

But in normal use, it won't.

Yes.

I need to implement getAvailableFor(field) where field is 'state', 'city', 'dept', 'researcher'

I'll make a function getFilteredStudiesIgnoring(ignoreField) {

  const criteria = usaAuthorFilter.value;

  return allStudies.filter(study => {

    let match = checkUSAAuthorCriteria(study, criteria);

    if (ignoreField !== 'state') {

      const sel = stateFilter.value;

      match = match && (sel === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.state === sel)));

    }

    if (ignoreField !== 'city') {

      const sel = cityFilter.value;

      match = match && (sel === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.city === sel)));

    }

    if (ignoreField !== 'dept') {

      const sel = deptFilter.value;

      match = match && (sel === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.department === sel)));

    }

    if (ignoreField !== 'researcher') {

      const sel = researcherFilter.value;

      match = match && (sel === 'all' || study.authors.some(a => a.name === sel));

    }

    return match;

  });

}

Then, getAvailableStates() {

  const studies = getFilteredStudiesIgnoring('state');

  const set = new Set();

  studies.forEach(study => {

    study.authors.forEach(a => {

      a.affiliations.forEach(aff => {

        if (aff.isUSA && aff.state) set.add(aff.state);

      });

    });

  });

  return [...set].sort();

}

Similarly for cities, depts, researchers.

For researchers: set.add(a.name) but only if authorHasUSAAffiliation(a)? No, since the filter is on any author == selected, but since usaAuthorFilter is separate, but in the parsing, allStudies are already those with isUSAResearch true, meaning at least one USA aff.

But for researcher filter, it's all authors in the study, but only studies with USA.

Anyway, in populate, it's researchers.add(author.name) for all authors in USA studies.

Similarly here.

For getAvailableResearchers() {

  const studies = getFilteredStudiesIgnoring('researcher');

  const set = new Set();

  studies.forEach(study => {

    study.authors.forEach(a => {

      set.add(a.name);

    });

  });

  return [...set].sort();

}

Yes.

For depts: if (aff.isUSA && aff.department) set.add(aff.department)

For cities: if (aff.isUSA && aff.city) set.add(aff.city)

Yes.

Then, in updateFilterOptions() {

  const availableStates = getAvailableStates();

  populateSelect(stateFilter, availableStates, 'States');

  const availableCities = getAvailableCities();

  populateSelect(cityFilter, availableCities, 'Cities');

  const availableDepts = getAvailableDepts();

  populateSelect(deptFilter, availableDepts, 'Departments');

  const availableResearchers = getAvailableResearchers();

  populateSelect(researcherFilter, availableResearchers, 'Researchers');

}

And modify populateSelect to:

function populateSelect(element, items, plural) {

  const currentValue = element.value;

  element.innerHTML = `<option value="all">All ${plural}</option>`;

  items.forEach(item => {

    const option = document.createElement('option');

    option.value = item;

    option.textContent = item;

    element.appendChild(option);

  });

  if (items.includes(currentValue) || currentValue === 'all') {

    element.value = currentValue;

  } else {

    element.value = 'all';

    // since changed, need to reapply

    applyFilters(); // but this might cause recursion if multiple resets

  }

}

If multiple need reset, calling applyFilters inside might call update again.

To avoid, I can collect if any reset happened, and after updating all, if any reset, call applyFilters once.

Yes, better.

So, let needsReapply = false;

Then, in populateSelect, if not includes and current !== 'all', then element.value = 'all'; needsReapply = true;

Then, after all populates, if (needsReapply) applyFilters();

But since applyFilters calls updateFilterOptions at the end, it would recurse.

But if after reset, the available might change, but since resetting to 'all' broadens, the available will include more, and since now value='all', it won't reset again.

So, if I call applyFilters again, it will recompute filteredStudies with the reset filters, then update options again, but this time no reset needed.

So, depth 2 at most.

But to prevent infinite, I can add a flag.

But in practice, ok.

I can make applyFilters not call update if inUpdate or something.

But simplest: since it's small, and recursion shallow, ok.

I need to call updateFilterOptions after applyFilters.

In the code, after processFiles, populateFilters(allStudies), but now I can rename populateFilters to initialPopulate, but since now dynamic, in processFiles, after allStudies = ..., then resetFilters() which sets all to 'all', then applyFilters(), which will compute filtered = all, then updateFilterOptions which populates with all available (which is all since all 'all').

Yes.

The initial populateFilters is similar to updateFilterOptions with no filters set.

Yes.

Also, the usaAuthorFilter change should also trigger update, since it affects.

Yes, since it's in the listeners.

For usaAuthorFilter, since its options are fixed, no need to update it.

But in getFilteredStudiesIgnoring, it always includes the usaAuthor criteria, since it's not ignored for the fields.

Yes, because usaAuthor is not dynamic.

If I change usaAuthor, it might affect available locations etc., yes, and since change calls applyFilters, which updates options.

Yes.

I think this works.

Now, I need to implement these functions.

Also, note that in parseAffiliation, the state is set to full name US_STATES[part]

Yes.

I think that's it.

For the code, I need to rewrite the entire HTML, but only change the script part.

The user said "rewrite all this code", so output the full modified HTML.

Yes.

Also, perhaps add counts to options, like "California (10)", but the user didn't ask, so no.

Just the options that have studies.

Yes.

One thing: when selecting a specific, the other filters update to only those compatible.

And if selecting makes some other filter's current value invalid, reset it to 'all' and reapply.

But since the selection is before update, and update checks if current still available.

When change happens, applyFilters computes with new value, then update options, and if some other filter's value not in new available, reset it and reapply.

Yes.

For example, suppose state=CA, then available cities = those in CA.

If I then set state=NY, then filteredStudies become those in NY, then available cities = those in NY, but if city was set to a CA city, it won't be in available, so reset city to 'all', and since reset, reapply filters, now with state=NY, city='all', recompute filtered, update options again, now cities in NY, and since city='all' is ok, no more.

Yes, perfect.

I need to implement this in the script.

Let me outline the changes:

- Add the getFilteredStudiesIgnoring(ignoreField) function.

- Add getAvailableStates(), getAvailableCities(), getAvailableDepts(), getAvailableResearchers() using above.

- Add updateFilterOptions() which computes available for each, then populateSelect for each.

- Modify populateSelect to take plural or label, and handle the reset, but since needsReapply, make it return true if reset.

No, since global, I can let needsReapply = false; before loop, then in each populate if reset set true.

Then after all, if(needsReapply) applyFilters();

- In applyFilters, at the end, call updateFilterOptions();

- Remove the old populateFilters, and in processFiles, after allStudies, actionButtons etc, then resetFilters(); which sets all to 'all', applyFilters();

But usaAuthor default is 'any', state etc 'all'

In resetFilters, set usaAuthorFilter.value = 'any';

Others 'all'

Yes.

In the HTML, the selects have <option value="all">All States</option> etc.

But initially empty except that.

No, in code, populated later.

In processFiles, after parsing, if(allStudies.length >0){ ... populateFilters(allStudies); applyFilters(); ...}

Now, instead, remove populateFilters, and in if, dashboard.remove hidden, then resetFilters(); // which will call applyFilters, and inside it updateFilterOptions which will populate with all.

But in updateFilterOptions, if no studies, but anyway.

In resetFilters, set values, then applyFilters();

Yes.

But initially, before files, selects are empty except the all option? No, in HTML, they have <option value="all">All ...</option>

For state: <option value="all">All States</option>

Similarly others.

Yes.

When populating, we clear and add.

Yes.

One issue: first time, when processFiles, allStudies set, then resetFilters sets 'all', applyFilters computes filtered=allStudies (since all 'all'), then updateFilterOptions computes available ignoring each, but since others 'all', available = all possible from allStudies.

Then populate each with those.

Perfect.

Later, when filter changes, it works.

For usaAuthorFilter, since 'any' is default, and options fixed.

Yes.

I think that's the plan.```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PubMed Research Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      #filters {
    overflow-y: auto;
    max-height: calc(100vh - 4rem);
    scrollbar-width: thin; /* For Firefox */
    scrollbar-color: var(--border-color) var(--surface-color);
}

#filters::-webkit-scrollbar {
    width: 6px; /* Thin width */
}

#filters::-webkit-scrollbar-track {
    background: var(--surface-color); /* Darker track */
    border-radius: 10px;
}

#filters::-webkit-scrollbar-thumb {
    background: var(--border-color); /* Dark thumb */
    border-radius: 10px;
}

#filters::-webkit-scrollbar-thumb:hover {
    background: #555; /* Slightly lighter on hover for better UX */
}
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #3498db;
            --primary-hover: #2980b9;
            --text-color: #f5f5f5;
            --text-muted-color: #9e9e9e;
            --border-color: #333;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --font-family: 'Inter', sans-serif;
            --success-color: #27ae60;
            --warning-color: #f39c12;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2rem;
            font-size: 16px;
        }

        /* --- Main Layout & Header --- */
        .container {
            max-width: 1600px;
            margin: auto;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        header {
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 1.5rem;
        }

        header h1 {
            font-size: 2.5rem;
            margin: 0;
            color: var(--primary-color);
            font-weight: 700;
        }

        header p {
            font-size: 1.1rem;
            color: var(--text-muted-color);
            max-width: 700px;
            margin: 0.5rem auto 0;
        }
        
        /* --- File Input with Drag & Drop --- */
        .file-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
            background-color: var(--surface-color);
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .file-upload-area:hover, .file-upload-area.drag-over {
            background-color: #2a2a2a;
            border-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .file-upload-area.drag-over {
            background-color: rgba(52, 152, 219, 0.1);
            border-color: var(--success-color);
        }

        .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .file-label {
            background-color: var(--primary-color);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
            border: none;
        }
        
        .file-label:hover {
            background-color: var(--primary-hover);
        }

        #fileInput {
            display: none;
        }

        #file-list {
            color: var(--text-muted-color);
            font-style: italic;
        }

        /* --- Action Buttons --- */
        .action-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .action-btn {
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .action-btn:hover {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- Dashboard --- */
        #dashboard {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 2rem;
            align-items: start;
        }

        /* --- Filters --- */
        #filters {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: sticky;
            top: 2rem;
        }

        .filter-group {
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
        }

        .filter-group h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.75rem;
        }
        
        .filter-group select{
            width: 100%;
            padding: 10px;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        
        .filter-group select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        /* --- Main Content --- */
        #main-content {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            min-width: 0;
        }

        /* --- View Toggle --- */
        .view-toggle {
            display: flex;
            background-color: var(--surface-color);
            border-radius: 12px;
            padding: 0.5rem;
            gap: 0.5rem;
        }

        .view-btn {
            flex: 1;
            padding: 10px;
            background: none;
            border: none;
            color: var(--text-muted-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .view-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* --- Charts --- */
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
        }

        .chart-wrapper {
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            position: relative;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .chart-wrapper:hover {
            transform: translateY(-2px);
        }

        .chart-expand-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(52, 152, 219, 0.8);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* --- Map --- */
        #mapView {
            height: 600px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px var(--shadow-color);
        }

        /* --- Results List --- */
        #results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: var(--surface-color);
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
        }
        
        #results-count {
            font-weight: 500;
        }

        #results-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .study-item {
            background-color: var(--surface-color);
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            overflow: hidden;
            border: 1px solid transparent;
            transition: border-color 0.3s;
        }

        .study-item:hover {
            border-color: var(--primary-color);
        }

        .study-header {
            padding: 1.5rem;
        }

        .study-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 0.75rem 0;
        }
        
        .study-link {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }
        
        .study-link:hover {
            text-decoration: underline;
        }

        .abstract-toggle {
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            color: var(--text-muted-color);
            background-color: rgba(255, 255, 255, 0.03);
            border-top: 1px solid var(--border-color);
            transition: background-color 0.3s;
        }

        .abstract-toggle:hover {
            background-color: rgba(255, 255, 255, 0.07);
        }
        
        .abstract-toggle::after {
            content: '‚ñº';
            float: right;
            transition: transform 0.3s;
        }
        
        .abstract-toggle.open::after {
            transform: rotate(180deg);
        }

        .abstract-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            padding: 0 1.5rem;
            line-height: 1.6;
        }

        .abstract-content.open {
            max-height: 1000px;
            padding: 1.5rem;
        }

        /* --- Modal --- */
        .modal {
            display: flex;
            align-items: center;
            justify-content: center;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .modal.open {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--surface-color);
            padding: 2.5rem;
            border-radius: 12px;
            box-shadow: 0 5px 25px var(--shadow-color);
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            transform: scale(0.95);
            transition: transform 0.3s;
        }
        
        .modal.open .modal-content {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.8rem;
            color: var(--primary-color);
        }

        .close-button {
            background: none;
            border: none;
            font-size: 2.5rem;
            color: var(--text-muted-color);
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-button:hover {
            color: var(--text-color);
        }
        
        .modal-body p {
            line-height: 1.7;
            color: var(--text-muted-color);
        }
        .modal-body strong {
            color: var(--text-color);
        }

        .chart-modal-content {
            height: 70vh;
            width: 100%;
        }
        
        /* --- Loader --- */
        #loader {
            display: none;
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--primary-color);
            animation: spin 1s ease infinite;
            margin: 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* --- Hidden class --- */
        .hidden {
            display: none !important;
        }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            #dashboard {
                grid-template-columns: 1fr;
            }
            
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>

    <!-- Welcome Modal -->
    <div id="welcomeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üöÄ Advanced PubMed Research Analyzer</h2>
                <button class="close-button" id="closeModalBtn">√ó</button>
            </div>
            <div class="modal-body">
                <p>Welcome to the <strong>Advanced PubMed Research Analyzer</strong> - your comprehensive tool for exploring scientific literature!</p>
                <p><strong>‚ú® New Features:</strong></p>
                <ul>
                    <li><strong>üéØ Drag & Drop:</strong> Simply drag PubMed .txt files to upload</li>
                    <li><strong>üó∫Ô∏è Interactive Map:</strong> Visualize research locations with clickable pins</li>
                    <li><strong>üìä Expandable Charts:</strong> Click any chart to view in full screen</li>
                    <li><strong>üë• Author Analytics:</strong> Discover top researchers and collaborations</li>
                    <li><strong>üìÅ Excel Export:</strong> Download your filtered results as XLSX</li>
                    <li><strong>üîç Advanced Filtering:</strong> Filter by USA author criteria and more</li>
                </ul>
                <p><strong>How to get started:</strong></p>
                <ol>
                    <li>Drag & drop or select PubMed .txt files</li>
                    <li>Explore data with interactive charts and map</li>
                    <li>Use filters to narrow down results</li>
                    <li>Export your findings to Excel</li>
                </ol>
            </div>
        </div>
    </div>

    <!-- Chart Expansion Modal -->
    <div id="chartModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="chartModalTitle">Chart View</h2>
                <button class="close-button" id="closeChartModalBtn">√ó</button>
            </div>
            <div class="modal-body">
                <div class="chart-modal-content">
                    <canvas id="expandedChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>üß¨ Advanced PubMed Research Analyzer</h1>
            <p>Discover, Analyze, and Export Scientific Research Trends Across the United States</p>
        </header>

        <div class="file-upload-area" id="fileUploadArea">
            <div class="upload-icon">üìÅ</div>
            <button class="file-label" onclick="document.getElementById('fileInput').click()">
                Select PubMed Files
            </button>
            <p>or drag and drop .txt files here</p>
            <input type="file" id="fileInput" multiple accept=".txt">
            <p id="file-list">No files selected.</p>
        </div>

        <div class="action-buttons hidden" id="actionButtons">
            <button class="action-btn" id="exportBtn">
                üìä Export to Excel
            </button>
            <button class="action-btn" id="statsBtn">
                üìà View Statistics
            </button>
            <button class="action-btn" id="resetBtn">
                üîÑ Reset Filters
            </button>
        </div>
        
        <div id="loader">
            <div class="spinner"></div>
            <p>Analyzing files...</p>
        </div>

        <div id="dashboard" class="hidden">
            <aside id="filters" style="overflow-y: auto; max-height: calc(100vh - 4rem); padding-right: 15px;">
                <div class="filter-group">
                    <h3>üá∫üá∏ USA Authors</h3>
                    <select id="usaAuthorFilter" class="filter-select">
                        <option value="any">Any USA Authors (Default)</option>
                        <option value="at-least-one">At Least One USA Author</option>
                        <option value="first">First Author from USA</option>
                        <option value="last">Last Author from USA</option>
                        <option value="all">All Authors from USA</option>
                    </select>
                </div>
                <div class="filter-group">
                    <h3>üìç Location</h3>
                    <select id="stateFilter" class="filter-select">
                        <option value="all">All States</option>
                    </select>
                    <select id="cityFilter" class="filter-select">
                        <option value="all">All Cities</option>
                    </select>
                </div>
                <div class="filter-group">
                    <h3>üèõÔ∏è Department</h3>
                    <select id="deptFilter" class="filter-select">
                        <option value="all">All Departments</option>
                    </select>
                </div>
                <div class="filter-group">
                    <h3>üë®‚Äçüî¨ Researcher</h3>
                    <select id="researcherFilter" class="filter-select">
                        <option value="all">All Researchers</option>
                    </select>
                </div>
            </aside>
            <main id="main-content">
                <div class="view-toggle">
                    <button class="view-btn active" data-view="charts">üìä Charts</button>
                    <button class="view-btn" data-view="map">üó∫Ô∏è Map</button>
                    <button class="view-btn" data-view="authors">üë• Authors</button>
                </div>

                <div id="chartsView">
                    <div class="charts-container">
                        <div class="chart-wrapper" data-chart="state">
                            <button class="chart-expand-btn">üîç Expand</button>
                            <canvas id="stateChart"></canvas>
                        </div>
                        <div class="chart-wrapper" data-chart="city">
                            <button class="chart-expand-btn">üîç Expand</button>
                            <canvas id="cityChart"></canvas>
                        </div>
                        <div class="chart-wrapper" data-chart="department">
                            <button class="chart-expand-btn">üîç Expand</button>
                            <canvas id="deptChart"></canvas>
                        </div>
                        <div class="chart-wrapper" data-chart="timeline">
                            <button class="chart-expand-btn">üîç Expand</button>
                            <canvas id="timelineChart"></canvas>
                        </div>
                    </div>
                </div>

                <div id="mapView" class="hidden"></div>

                <div id="authorsView" class="hidden">
                    <div class="charts-container">
                        <div class="chart-wrapper" data-chart="top-authors">
                            <button class="chart-expand-btn">üîç Expand</button>
                            <canvas id="topAuthorsChart"></canvas>
                        </div>
                        <div class="chart-wrapper" data-chart="collaboration">
                            <button class="chart-expand-btn">üîç Expand</button>
                            <canvas id="collaborationChart"></canvas>
                        </div>
                    </div>
                </div>

                <div id="results-header">
                    <h2 id="results-count">Showing 0 Studies</h2>
                </div>
                <div id="results-list"></div>
            </main>
        </div>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- DOM Elements ---
        const fileInput = document.getElementById('fileInput');
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileListDisplay = document.getElementById('file-list');
        const loader = document.getElementById('loader');
        const dashboard = document.getElementById('dashboard');
        const actionButtons = document.getElementById('actionButtons');
        const resultsCountEl = document.getElementById('results-count');
        const resultsListEl = document.getElementById('results-list');

        // Filters
        const usaAuthorFilter = document.getElementById('usaAuthorFilter');
        const stateFilter = document.getElementById('stateFilter');
        const cityFilter = document.getElementById('cityFilter');
        const deptFilter = document.getElementById('deptFilter');
        const researcherFilter = document.getElementById('researcherFilter');

        // Views
        const viewBtns = document.querySelectorAll('.view-btn');
        const chartsView = document.getElementById('chartsView');
        const mapView = document.getElementById('mapView');
        const authorsView = document.getElementById('authorsView');

        // Modals
        const welcomeModal = document.getElementById('welcomeModal');
        const chartModal = document.getElementById('chartModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const closeChartModalBtn = document.getElementById('closeChartModalBtn');

        // Action buttons
        const exportBtn = document.getElementById('exportBtn');
        const statsBtn = document.getElementById('statsBtn');
        const resetBtn = document.getElementById('resetBtn');

        // --- State ---
        let allStudies = [];
        let filteredStudies = [];
        let charts = {};
        let chartData = {}; // Store chart data for expansion
        let map = null;
        let currentView = 'charts';

        // --- Constants ---
        const USA_SYNONYMS = ['USA', 'U.S.A', 'U.S.', 'US', 'United States of America', 'United States'];
        const US_STATES = {
            "AL": "Alabama", "AK": "Alaska", "AZ": "Arizona", "AR": "Arkansas", "CA": "California",
            "CO": "Colorado", "CT": "Connecticut", "DE": "Delaware", "FL": "Florida", "GA": "Georgia",
            "HI": "Hawaii", "ID": "Idaho", "IL": "Illinois", "IN": "Indiana", "IA": "Iowa",
            "KS": "Kansas", "KY": "Kentucky", "LA": "Louisiana", "ME": "Maine", "MD": "Maryland",
            "MA": "Massachusetts", "MI": "Michigan", "MN": "Minnesota", "MS": "Mississippi",
            "MO": "Missouri", "MT": "Montana", "NE": "Nebraska", "NV": "Nevada", "NH": "New Hampshire",
            "NJ": "New Jersey", "NM": "New Mexico", "NY": "New York", "NC": "North Carolina",
            "ND": "North Dakota", "OH": "Ohio", "OK": "Oklahoma", "OR": "Oregon", "PA": "Pennsylvania",
            "RI": "Rhode Island", "SC": "South Carolina", "SD": "South Dakota", "TN": "Tennessee",
            "TX": "Texas", "UT": "Utah", "VT": "Vermont", "VA": "Virginia", "WA": "Washington",
            "WV": "West Virginia", "WI": "Wisconsin", "WY": "Wyoming", "DC": "District of Columbia"
        };
        const STATE_ABBREVIATIONS = Object.keys(US_STATES);

        // State coordinates for map
        const STATE_COORDS = {
            "Alabama": [32.806671, -86.79113], "Alaska": [61.370716, -152.404419], "Arizona": [33.729759, -111.431221],
            "Arkansas": [34.969704, -92.373123], "California": [36.116203, -119.681564], "Colorado": [39.059811, -105.311104],
            "Connecticut": [41.767, -72.677], "Delaware": [39.161921, -75.526755], "Florida": [27.4518, -81.5158],
            "Georgia": [32.9866, -83.6487], "Hawaii": [21.1098, -157.5311], "Idaho": [44.2394, -114.5103],
            "Illinois": [40.349457, -88.986137], "Indiana": [39.790942, -86.147685], "Iowa": [42.031974, -93.581543],
            "Kansas": [38.572954, -98.580493], "Kentucky": [37.669037, -84.670067], "Louisiana": [31.1801, -91.8749],
            "Maine": [44.323535, -69.765261], "Maryland": [39.063946, -76.802101], "Massachusetts": [42.2352, -71.0275],
            "Michigan": [43.326618, -84.536095], "Minnesota": [45.7326, -93.9196], "Mississippi": [32.7673, -89.6812],
            "Missouri": [38.572954, -92.189283], "Montana": [47.052952, -110.454353], "Nebraska": [41.590939, -99.675285],
            "Nevada": [39.161921, -117.055374], "New Hampshire": [43.452492, -71.563896], "New Jersey": [40.314100, -74.756138],
            "New Mexico": [34.97273, -105.030889], "New York": [42.659829, -75.615], "North Carolina": [35.771, -78.638],
            "North Dakota": [47.518169, -99.930811], "Ohio": [40.367474, -82.996216], "Oklahoma": [35.482309, -97.534994],
            "Oregon": [44.931109, -120.768204], "Pennsylvania": [40.269789, -76.875613], "Rhode Island": [41.82355, -71.422132],
            "South Carolina": [33.836082, -81.163727], "South Dakota": [44.268543, -99.756012], "Tennessee": [35.771, -86.25],
            "Texas": [31.106, -97.6475], "Utah": [39.161921, -111.892622], "Vermont": [44.26639, -72.58133],
            "Virginia": [37.54, -78.64], "Washington": [47.042418, -120.81], "West Virginia": [38.349497, -81.633294],
            "Wisconsin": [44.95, -89.5], "Wyoming": [42.7475, -107.2085], "District of Columbia": [38.8974, -77.0365]
        };

        // --- Modal Logic ---
        const showModal = (modal) => modal.classList.add('open');
        const closeModal = (modal) => modal.classList.remove('open');

        closeModalBtn.addEventListener('click', () => closeModal(welcomeModal));
        closeChartModalBtn.addEventListener('click', () => closeModal(chartModal));
        [welcomeModal, chartModal].forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal(modal);
            });
        });

        showModal(welcomeModal);

        // --- Drag & Drop File Handling ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            fileUploadArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            fileUploadArea.addEventListener(eventName, () => {
                fileUploadArea.classList.add('drag-over');
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            fileUploadArea.addEventListener(eventName, () => {
                fileUploadArea.classList.remove('drag-over');
            });
        });

        fileUploadArea.addEventListener('drop', handleDrop);
        fileUploadArea.addEventListener('click', () => fileInput.click());

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            processFiles(files);
        }

        fileInput.addEventListener('change', (e) => {
            processFiles(e.target.files);
        });

        async function processFiles(files) {
            if (files.length === 0) {
                fileListDisplay.textContent = 'No files selected.';
                return;
            }
            
            fileListDisplay.textContent = `${files.length} file(s) selected: ${[...files].map(f => f.name).join(', ')}`;
            loader.style.display = 'block';
            dashboard.classList.add('hidden');
            actionButtons.classList.add('hidden');

            // Reset state
            allStudies = [];
            filteredStudies = [];
            
            // Artificial delay to show loader
            await new Promise(resolve => setTimeout(resolve, 500));

            try {
                const allTexts = await Promise.all([...files].map(file => file.text()));
                const combinedText = allTexts.join('\n\n');
                
                allStudies = parsePubmedText(combinedText);
                
                loader.style.display = 'none';
                if(allStudies.length > 0) {
                    dashboard.classList.remove('hidden');
                    actionButtons.classList.remove('hidden');
                    resetFilters();
                    initializeMap();
                } else {
                    fileListDisplay.textContent = 'No USA-based studies found in the selected files.';
                }
            } catch (error) {
                loader.style.display = 'none';
                fileListDisplay.textContent = 'Error processing files. Please try again.';
                console.error('File processing error:', error);
            }
        }

        function parsePubmedText(text) {
            const records = text.split('PMID- ').slice(1);
            const studies = [];

            for (const record of records) {
                const lines = record.split('\n');
                let currentStudy = { pmid: lines[0].trim(), authors: [], isUSAResearch: false, year: null };
                let currentField = '';
                let lastFauAuthor = null;

                for (const line of lines.slice(1)) {
                    const tagMatch = line.match(/^([A-Z]{2,4}) {1,2}- /);
                    if (tagMatch) {
                        currentField = tagMatch[1];
                        const content = line.substring(tagMatch[0].length).trim();
                        
                        switch(currentField) {
                            case 'TI':
                                currentStudy.title = (currentStudy.title || '') + content + ' ';
                                break;
                            case 'AB':
                                currentStudy.abstract = (currentStudy.abstract || '') + content + ' ';
                                break;
                            case 'FAU':
                                lastFauAuthor = { name: content, affiliations: [] };
                                currentStudy.authors.push(lastFauAuthor);
                                break;
                            case 'AD':
                                if (lastFauAuthor) {
                                    const affiliation = parseAffiliation(content);
                                    if (affiliation.isUSA) {
                                        currentStudy.isUSAResearch = true;
                                    }
                                    lastFauAuthor.affiliations.push(affiliation);
                                }
                                break;
                            case 'DP':
                                // Extract year from date
                                const yearMatch = content.match(/(\d{4})/);
                                if (yearMatch) {
                                    currentStudy.year = parseInt(yearMatch[1]);
                                }
                                break;
                        }
                    } else if (line.trim()) { // Handle continuation lines
                        switch(currentField) {
                            case 'TI':
                                currentStudy.title = (currentStudy.title || '') + line.trim() + ' ';
                                break;
                            case 'AB':
                                currentStudy.abstract = (currentStudy.abstract || '') + line.trim() + ' ';
                                break;
                            case 'AD': // Multi-line affiliations
                                if (lastFauAuthor && lastFauAuthor.affiliations.length > 0) {
                                    const lastAffiliation = lastFauAuthor.affiliations[lastFauAuthor.affiliations.length - 1];
                                    lastAffiliation.full += ' ' + line.trim();
                                    // Re-parse with the added text
                                    const reparsedAffiliation = parseAffiliation(lastAffiliation.full);
                                    if (reparsedAffiliation.isUSA) currentStudy.isUSAResearch = true;
                                    lastFauAuthor.affiliations[lastFauAuthor.affiliations.length - 1] = reparsedAffiliation;
                                }
                                break;
                        }
                    }
                }
                
                if (currentStudy.isUSAResearch) {
                    if (currentStudy.title) currentStudy.title = currentStudy.title.trim();
                    if (currentStudy.abstract) currentStudy.abstract = currentStudy.abstract.trim();
                    currentStudy.link = `https://pubmed.ncbi.nlm.nih.gov/${currentStudy.pmid}/`;
                    studies.push(currentStudy);
                }
            }
            return studies;
        }

        function parseAffiliation(affiliationText) {
            const result = { full: affiliationText.trim(), isUSA: false, country: null, state: null, city: null, department: null };
            const parts = result.full.split(',').map(p => p.trim());
            
            // Check for USA
            const countryPart = parts.find(p => USA_SYNONYMS.some(syn => p.includes(syn)));
            if(countryPart) {
                result.isUSA = true;
                result.country = 'USA';
            }
            
            // Very simple heuristic to find state, city, and department
            if (result.isUSA) {
                for (let i = parts.length - 1; i >= 0; i--) {
                    const part = parts[i].split(' ')[0]; // e.g., "NJ," or "NJ" from "Piscataway, NJ, USA"
                    if (!result.state && STATE_ABBREVIATIONS.includes(part)) {
                        result.state = US_STATES[part];
                        if(i > 0 && !result.city) {
                           result.city = parts[i-1];
                        }
                    }
                }
                // Assume the rest is the department/institution
                const cityIndex = result.city ? parts.indexOf(result.city) : -1;
                if(cityIndex > 0) {
                    result.department = parts.slice(0, cityIndex).join(', ');
                } else {
                    result.department = parts.slice(0, parts.length - (result.state ? 2 : 1)).join(', ');
                }
            }

            return result;
        }

        // --- Helper Functions for USA Author Filter ---
        function authorHasUSAAffiliation(author) {
            return author.affiliations.some(aff => aff.isUSA);
        }

        function checkUSAAuthorCriteria(study, criteria) {
            const usaAuthors = study.authors.filter(authorHasUSAAffiliation);
            
            switch(criteria) {
                case 'any':
                    return usaAuthors.length > 0; // Default - any USA authors
                case 'at-least-one':
                    return usaAuthors.length > 0;
                case 'first':
                    return study.authors.length > 0 && authorHasUSAAffiliation(study.authors[0]);
                case 'last':
                    // The last author is the senior/corresponding author
                    const lastAuthorIndex = study.authors.length - 1;
                    return study.authors.length > 0 && lastAuthorIndex >= 0 && authorHasUSAAffiliation(study.authors[lastAuthorIndex]);
                case 'all':
                    return study.authors.length > 0 && study.authors.every(authorHasUSAAffiliation);
                default:
                    return true;
            }
        }

        // --- View Toggle Logic ---
        viewBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                switchView(view);
            });
        });

        function switchView(view) {
            // Update buttons
            viewBtns.forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-view="${view}"]`).classList.add('active');
            
            // Hide all views
            chartsView.classList.add('hidden');
            mapView.classList.add('hidden');
            authorsView.classList.add('hidden');
            
            // Show selected view
            currentView = view;
            switch(view) {
                case 'charts':
                    chartsView.classList.remove('hidden');
                    updateCharts(filteredStudies);
                    break;
                case 'map':
                    mapView.classList.remove('hidden');
                    updateMap(filteredStudies);
                    break;
                case 'authors':
                    authorsView.classList.remove('hidden');
                    updateAuthorCharts(filteredStudies);
                    break;
            }
        }

        // --- Filtering Logic ---
        function getFilteredStudiesIgnoring(ignoreField) {
            const criteria = usaAuthorFilter.value;
            const selectedState = stateFilter.value;
            const selectedCity = cityFilter.value;
            const selectedDept = deptFilter.value;
            const selectedResearcher = researcherFilter.value;

            return allStudies.filter(study => {
                let match = checkUSAAuthorCriteria(study, criteria);

                if (ignoreField !== 'state') {
                    match = match && (selectedState === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.state === selectedState)));
                }
                if (ignoreField !== 'city') {
                    match = match && (selectedCity === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.city === selectedCity)));
                }
                if (ignoreField !== 'dept') {
                    match = match && (selectedDept === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.department === selectedDept)));
                }
                if (ignoreField !== 'researcher') {
                    match = match && (selectedResearcher === 'all' || study.authors.some(a => a.name === selectedResearcher));
                }

                return match;
            });
        }

        function getAvailableStates() {
            const studies = getFilteredStudiesIgnoring('state');
            const states = new Set();
            studies.forEach(study => {
                study.authors.forEach(author => {
                    author.affiliations.forEach(aff => {
                        if (aff.isUSA && aff.state) states.add(aff.state);
                    });
                });
            });
            return [...states].sort();
        }

        function getAvailableCities() {
            const studies = getFilteredStudiesIgnoring('city');
            const cities = new Set();
            studies.forEach(study => {
                study.authors.forEach(author => {
                    author.affiliations.forEach(aff => {
                        if (aff.isUSA && aff.city) cities.add(aff.city);
                    });
                });
            });
            return [...cities].sort();
        }

        function getAvailableDepts() {
            const studies = getFilteredStudiesIgnoring('dept');
            const departments = new Set();
            studies.forEach(study => {
                study.authors.forEach(author => {
                    author.affiliations.forEach(aff => {
                        if (aff.isUSA && aff.department) departments.add(aff.department);
                    });
                });
            });
            return [...departments].sort();
        }

        function getAvailableResearchers() {
            const studies = getFilteredStudiesIgnoring('researcher');
            const researchers = new Set();
            studies.forEach(study => {
                study.authors.forEach(author => {
                    researchers.add(author.name);
                });
            });
            return [...researchers].sort();
        }

        function populateSelect(element, items, plural) {
            const currentValue = element.value;
            element.innerHTML = `<option value="all">All ${plural}</option>`;
            items.forEach(item => {
                const option = document.createElement('option');
                option.value = item;
                option.textContent = item;
                element.appendChild(option);
            });
            if (currentValue === 'all' || items.includes(currentValue)) {
                element.value = currentValue;
                return false; // no reset
            } else {
                element.value = 'all';
                return true; // reset happened
            }
        }

        function updateFilterOptions() {
            let needsReapply = false;

            const availableStates = getAvailableStates();
            if (populateSelect(stateFilter, availableStates, 'States')) needsReapply = true;

            const availableCities = getAvailableCities();
            if (populateSelect(cityFilter, availableCities, 'Cities')) needsReapply = true;

            const availableDepts = getAvailableDepts();
            if (populateSelect(deptFilter, availableDepts, 'Departments')) needsReapply = true;

            const availableResearchers = getAvailableResearchers();
            if (populateSelect(researcherFilter, availableResearchers, 'Researchers')) needsReapply = true;

            if (needsReapply) {
                applyFilters();
            }
        }

        function applyFilters() {
            const selectedUSAAuthor = usaAuthorFilter.value;
            const selectedState = stateFilter.value;
            const selectedCity = cityFilter.value;
            const selectedDept = deptFilter.value;
            const selectedResearcher = researcherFilter.value;
            
            filteredStudies = allStudies.filter(study => {
                const usaAuthorMatch = checkUSAAuthorCriteria(study, selectedUSAAuthor);
                const stateMatch = selectedState === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.state === selectedState));
                const cityMatch = selectedCity === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.city === selectedCity));
                const deptMatch = selectedDept === 'all' || study.authors.some(a => a.affiliations.some(aff => aff.department === selectedDept));
                const researcherMatch = selectedResearcher === 'all' || study.authors.some(a => a.name === selectedResearcher);

                return usaAuthorMatch && stateMatch && cityMatch && deptMatch && researcherMatch;
            });

            renderResults(filteredStudies);
            
            // Update current view
            switch(currentView) {
                case 'charts':
                    updateCharts(filteredStudies);
                    break;
                case 'map':
                    updateMap(filteredStudies);
                    break;
                case 'authors':
                    updateAuthorCharts(filteredStudies);
                    break;
            }

            updateFilterOptions();
        }

        [usaAuthorFilter, stateFilter, cityFilter, deptFilter, researcherFilter].forEach(filter => {
            filter.addEventListener('change', applyFilters);
        });

        // --- Action Button Logic ---
        exportBtn.addEventListener('click', exportToExcel);
        resetBtn.addEventListener('click', resetFilters);
        statsBtn.addEventListener('click', showStatistics);

        function exportToExcel() {
            if (filteredStudies.length === 0) {
                alert('No data to export. Please load some files first.');
                return;
            }

            const data = filteredStudies.map(study => ({
                PMID: study.pmid,
                Title: study.title || '',
                Abstract: study.abstract || '',
                Year: study.year || '',
                Authors: study.authors.map(a => a.name).join('; '),
                'USA States': [...new Set(study.authors.flatMap(a => 
                    a.affiliations.filter(aff => aff.isUSA && aff.state).map(aff => aff.state)
                ))].join('; '),
                'USA Cities': [...new Set(study.authors.flatMap(a => 
                    a.affiliations.filter(aff => aff.isUSA && aff.city).map(aff => aff.city)
                ))].join('; '),
                Departments: [...new Set(study.authors.flatMap(a => 
                    a.affiliations.filter(aff => aff.isUSA && aff.department).map(aff => aff.department)
                ))].join('; '),
                'PubMed Link': study.link
            }));

            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'PubMed Studies');
            XLSX.writeFile(wb, `pubmed_analysis_${new Date().toISOString().split('T')[0]}.xlsx`);
        }

        function resetFilters() {
            usaAuthorFilter.value = 'any';
            stateFilter.value = 'all';
            cityFilter.value = 'all';
            deptFilter.value = 'all';
            researcherFilter.value = 'all';
            applyFilters();
        }

        function showStatistics() {
            const stats = calculateStatistics(filteredStudies);
            alert(`üìä Dataset Statistics:\n\n` +
                  `Total Studies: ${stats.totalStudies}\n` +
                  `Total Authors: ${stats.totalAuthors}\n` +
                  `Unique USA States: ${stats.uniqueStates}\n` +
                  `Unique USA Cities: ${stats.uniqueCities}\n` +
                  `Year Range: ${stats.yearRange}\n` +
                  `Most Productive State: ${stats.topState}\n` +
                  `Most Productive Author: ${stats.topAuthor}`);
        }

        function calculateStatistics(studies) {
            const stats = {};
            stats.totalStudies = studies.length;
            const authors = new Set();
            const states = new Set();
            const cities = new Set();
            const years = [];
            const stateCounts = {};
            const authorCounts = {};

            studies.forEach(study => {
                if (study.year) years.push(study.year);
                study.authors.forEach(author => {
                    authors.add(author.name);
                    authorCounts[author.name] = (authorCounts[author.name] || 0) + 1;
                    author.affiliations.forEach(aff => {
                        if (aff.isUSA) {
                            if (aff.state) {
                                states.add(aff.state);
                                stateCounts[aff.state] = (stateCounts[aff.state] || 0) + 1;
                            }
                            if (aff.city) cities.add(aff.city);
                        }
                    });
                });
            });

            const topState = Object.entries(stateCounts).sort((a,b) => b[1] - a[1])[0];
            const topAuthor = Object.entries(authorCounts).sort((a,b) => b[1] - a[1])[0];

            stats.totalAuthors = authors.size;
            stats.uniqueStates = states.size;
            stats.uniqueCities = cities.size;
            stats.yearRange = years.length > 0 ? `${Math.min(...years)} - ${Math.max(...years)}` : 'N/A';
            stats.topState = topState ? `${topState[0]} (${topState[1]} studies)` : 'N/A';
            stats.topAuthor = topAuthor ? `${topAuthor[0]} (${topAuthor[1]} studies)` : 'N/A';

            return stats;
        }

        // --- Map Logic ---
        function initializeMap() {
            if (map) {
                map.remove();
            }
            map = L.map('mapView').setView([39.8283, -98.5795], 4); // Center of USA
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
        }

        function updateMap(studies) {
            if (!map) return;
            
            // Clear existing markers
            map.eachLayer(layer => {
                if (layer instanceof L.Marker) {
                    map.removeLayer(layer);
                }
            });

            const stateCounts = {};
            studies.forEach(study => {
                study.authors.forEach(author => {
                    author.affiliations.forEach(aff => {
                        if (aff.isUSA && aff.state) {
                            stateCounts[aff.state] = (stateCounts[aff.state] || 0) + 1;
                        }
                    });
                });
            });

            Object.entries(stateCounts).forEach(([state, count]) => {
                const coords = STATE_COORDS[state];
                if (coords) {
                    const marker = L.marker(coords).addTo(map);
                    marker.bindPopup(`<b>${state}</b><br>${count} studies<br><button onclick="filterByState('${state}')">Filter by this state</button>`);
                }
            });
        }

        // Global function for map popup buttons
        window.filterByState = function(state) {
            stateFilter.value = state;
            applyFilters();
            switchView('charts');
        };

        // --- Rendering Logic ---
        function renderResults(studies) {
            resultsCountEl.textContent = `Showing ${studies.length} Studies`;
            resultsListEl.innerHTML = '';
            
            if (studies.length === 0) {
                 resultsListEl.innerHTML = '<p style="text-align:center; color: var(--text-muted-color);">No studies match the current filters.</p>';
                 return;
            }

            studies.forEach(study => {
                const item = document.createElement('div');
                item.className = 'study-item';
                
                // Get USA authors info
                const usaAuthors = study.authors.filter(authorHasUSAAffiliation);
                const authorInfo = usaAuthors.length > 0 ? 
                    `<p><strong>USA Authors:</strong> ${usaAuthors.map(a => a.name).join(', ')}</p>` : '';
                
                item.innerHTML = `
                    <div class="study-header">
                        <h3 class="study-title">${study.title || 'No Title Available'}</h3>
                        ${study.year ? `<p><strong>Year:</strong> ${study.year}</p>` : ''}
                        ${authorInfo}
                        <a href="${study.link}" target="_blank" class="study-link">View on PubMed</a>
                    </div>
                    ${study.abstract ? `
                    <button class="abstract-toggle">Show Abstract</button>
                    <div class="abstract-content">
                        <p>${study.abstract}</p>
                    </div>` : ''}
                `;
                resultsListEl.appendChild(item);
            });
        }
        
        resultsListEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('abstract-toggle')) {
                const button = e.target;
                const content = button.nextElementSibling;
                button.classList.toggle('open');
                content.classList.toggle('open');
                button.textContent = button.classList.contains('open') ? 'Hide Abstract' : 'Show Abstract';
            }
        });

        // --- Chart Logic ---
        function updateCharts(studies) {
            const stateCounts = {};
            const cityCounts = {};
            const deptCounts = {};
            const yearCounts = {};

            studies.forEach(study => {
                const studyStates = new Set();
                const studyCities = new Set();
                const studyDepts = new Set();
                
                if (study.year) {
                    yearCounts[study.year] = (yearCounts[study.year] || 0) + 1;
                }
                
                study.authors.forEach(author => {
                    author.affiliations.forEach(aff => {
                        if (aff.isUSA) {
                            if (aff.state) studyStates.add(aff.state);
                            if (aff.city) studyCities.add(aff.city);
                            if (aff.department) studyDepts.add(aff.department);
                        }
                    });
                });
                
                studyStates.forEach(state => stateCounts[state] = (stateCounts[state] || 0) + 1);
                studyCities.forEach(city => cityCounts[city] = (cityCounts[city] || 0) + 1);
                studyDepts.forEach(dept => deptCounts[dept] = (deptCounts[dept] || 0) + 1);
            });

            // Get top data for charts
            const topCities = Object.entries(cityCounts).sort((a, b) => b[1] - a[1]).slice(0, 15);
            const topDepts = Object.entries(deptCounts).sort((a, b) => b[1] - a[1]).slice(0, 15);
            const sortedStates = Object.entries(stateCounts).sort((a,b) => b[1] - a[1]);
            const sortedYears = Object.entries(yearCounts).sort((a,b) => parseInt(a[0]) - parseInt(b[0]));

            // Store chart data for expansion
            chartData.state = {
                title: 'Studies per State',
                labels: sortedStates.map(s => s[0]),
                data: sortedStates.map(s => s[1]),
                type: 'bar'
            };
            chartData.city = {
                title: 'Top 15 Cities by Study Count',
                labels: topCities.map(c => c[0]),
                data: topCities.map(c => c[1]),
                type: 'bar'
            };
            chartData.department = {
                title: 'Top 15 Departments',
                labels: topDepts.map(d => d[0]),
                data: topDepts.map(d => d[1]),
                type: 'bar'
            };
            chartData.timeline = {
                title: 'Studies by Year',
                labels: sortedYears.map(y => y[0]),
                data: sortedYears.map(y => y[1]),
                type: 'line'
            };

            // Destroy existing charts
            Object.values(charts).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });

            charts.state = createBarChart('stateChart', chartData.state.title, chartData.state.labels, chartData.state.data);
            charts.city = createBarChart('cityChart', chartData.city.title, chartData.city.labels, chartData.city.data);
            charts.department = createBarChart('deptChart', chartData.department.title, chartData.department.labels, chartData.department.data);
            charts.timeline = createLineChart('timelineChart', chartData.timeline.title, chartData.timeline.labels, chartData.timeline.data);
        }

        function updateAuthorCharts(studies) {
            const authorCounts = {};
            const collaborationData = {};

            studies.forEach(study => {
                const usaAuthors = study.authors.filter(authorHasUSAAffiliation);
                usaAuthors.forEach(author => {
                    authorCounts[author.name] = (authorCounts[author.name] || 0) + 1;
                });

                // Track collaborations (studies with multiple USA authors)
                if (usaAuthors.length > 1) {
                    const colabKey = usaAuthors.length;
                    collaborationData[colabKey] = (collaborationData[colabKey] || 0) + 1;
                }
            });

            const topAuthors = Object.entries(authorCounts).sort((a, b) => b[1] - a[1]).slice(0, 20);
            const collaborationEntries = Object.entries(collaborationData).sort((a,b) => parseInt(a[0]) - parseInt(b[0]));

            // Store chart data for expansion
            chartData['top-authors'] = {
                title: 'Top 20 Authors by Study Count',
                labels: topAuthors.map(a => a[0]),
                data: topAuthors.map(a => a[1]),
                type: 'bar'
            };
            chartData.collaboration = {
                title: 'Collaboration Patterns (Authors per Study)',
                labels: collaborationEntries.map(c => `${c[0]} authors`),
                data: collaborationEntries.map(c => c[1]),
                type: 'bar'
            };

            if (charts.topAuthors) charts.topAuthors.destroy();
            if (charts.collaboration) charts.collaboration.destroy();

            charts.topAuthors = createBarChart('topAuthorsChart', chartData['top-authors'].title, 
                chartData['top-authors'].labels, chartData['top-authors'].data);
            charts.collaboration = createBarChart('collaborationChart', chartData.collaboration.title, 
                chartData.collaboration.labels, chartData.collaboration.data);
        }

        function createBarChart(canvasId, title, labels, data) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Count',
                        data: data,
                        backgroundColor: 'rgba(52, 152, 219, 0.7)',
                        borderColor: 'rgba(52, 152, 219, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: title,
                            color: 'white',
                            font: { size: 16 }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }

        function createLineChart(canvasId, title, labels, data) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Studies',
                        data: data,
                        borderColor: 'rgba(52, 152, 219, 1)',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: title,
                            color: 'white',
                            font: { size: 16 }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }

        // --- Chart Expansion Logic ---
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('chart-expand-btn')) {
                const wrapper = e.target.closest('.chart-wrapper');
                const chartType = wrapper.dataset.chart;
                expandChart(chartType);
            }
        });

        function expandChart(chartType) {
            const data = chartData[chartType];
            if (!data) return;

            const expandedCanvas = document.getElementById('expandedChart');
            const modalTitle = document.getElementById('chartModalTitle');
            
            modalTitle.textContent = data.title;
            
            // Destroy any existing chart in modal
            if (charts.expanded) {
                charts.expanded.destroy();
            }

            // Create new chart in modal
            const ctx = expandedCanvas.getContext('2d');
            
            if (data.type === 'line') {
                charts.expanded = createLineChart('expandedChart', data.title, data.labels, data.data);
            } else {
                charts.expanded = createBarChart('expandedChart', data.title, data.labels, data.data);
            }

            showModal(chartModal);
        }
    });
    </script>
</body>
</html>